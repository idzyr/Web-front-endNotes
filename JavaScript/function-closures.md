# 闭包

**作用；**	

​	闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰。

直观的说就是形成一个不销毁的栈环境。

​	通俗讲闭包就是一个函数引用另一个函数的变量，因为变量被引用着所以不会被回收，因此可以用来封装一个私有变量。这是优点也是缺点，不必要的闭包只会增加内存消耗。

或者说闭包就是子函数可以使用父函数的局部变量，还有父函数的参数。

> **提示；**
>
>  变量声明时如果不使用 **var** 关键字，那么它就是一个全局变量，即便它在函数内定义。
>

## 变量生命周期

全局变量的作用域是全局性的，即在整个JavaScript程序中，全局变量处处都在。

而在函数内部声明的变量，只在函数内部起作用。这些变量是局部变量，作用域是局部性的；函数的参数也是局部性的，只在函数内部起作用。



## 问题举例

### 计数器困境

设想下如果你想统计一些数值，且该计数器在所有函数中都是可用的。

你可以使用全局变量，函数设置计数器递增：

**使用全局变量；**

```js
let counter = 0;
 
function add() {
   return counter += 1;
}
 
add();
add();
add();
 
// 计数器现在为 3
```

计数器数值在执行 add() 函数时发生变化。

但问题来了，**页面上的任何脚本都能改变计数器**，即便没有调用 add() 函数。

如果我在函数内声明计数器，如果没有调用函数将无法修改计数器的值：

**函数内变量；**

```js
function add() {
    var counter = 0;
    return counter += 1;
}
 
add();
add();
add();
// 本意是想输出 3, 但事与愿违，输出的都是 1 !
```

> **提示；**
>
> ​	函数内定义的变量会在函数执行完成后自动回收，当函数再次被调用时重新被初始化。所以上面代码最终执行结果是1.

闭包就是为了解决上述问题的。

## 内嵌函数

在了解闭包前先，看一下内嵌函数。

在JavaScript中所有函数都能访问全局变量。 

- 实际上，在 JavaScript 中，所有函数都能访问它们**上一层的作用域。**

- JavaScript 支持嵌套函数。被嵌套的函数可以访问上一层的函数变量。也就是其父级函数作用域中的变量。

```js
 function add() {
            let counter = 0;
            function plus() {
                counter += 1;
            };
            //在add函数内调用plus函数
            plus();
            plus();
            plus();
            console.log(counter);
            // counter最终输出为3而非上次的1
            return counter;  //结束函数并返回结果
        };
        
        add(); //执行add函数

```

该实例中，内嵌函数 **plus()** 可以访问父函数的 **counter** 变量：

如果我们能在外部访问 **plus()** 函数，这样就能解决计数器的困境。但是上面案例中并不能。

我们同样需要确保 **counter = 0** 只执行一次。

我们需要闭包来解决问题。

## 闭包

为了实现闭包我们需要自我调用函数。来看下面的案例吧。

```js
        let add = (function () {
            let counter = 0;
            return function () {
                return counter += 1;
            };
        })();

        console.log(add());
        console.log(add());
        console.log(add());
        /*
        输出结果；
            1
            2   
            3
        */
```

**实例解析；**

1. 创建add变量其值被定义为一个自执行函数。

2. 自执行函数只会执行一次，定义counter变量赋值为0，并返回函数表达式给调用者。

3. 当使用add变量时实际我们时调用了自执行函数内部的匿名函数。

   这里匿名函数既能访问自执行函数内的变量同时自执行函数只会执行一次这样就保证了counter只会被初始化一次不会像之前局部变量那样被回收重新被初始化，同时这样做的好处就是只有使用add变量才能影响counter的值。保证变量的私有。

